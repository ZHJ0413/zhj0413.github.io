---
title: 观察者模式
categories: 3
tags: 前端
---

## 什么是观察者模式

观察者模式是一种设计模式，用于在对象之间建立一种一对多的依赖关系。在该模式中，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。

简单来说，观察者模式就像是订阅和通知的关系。主题对象就像一个发布者，而观察者对象就像订阅者。当主题对象的状态发生改变时，它会通知所有注册的观察者对象，观察者对象就能够获取到最新的状态并执行相应的操作。

观察者模式的优点在于它实现了对象间的解耦。主题对象并不需要知道观察者的具体细节，只需要知道观察者实现了特定的接口或遵循了约定。这样可以使系统的各个部分相互独立，易于维护和扩展。

## 举个例子

假设你有一个新闻发布系统，其中包括新闻主题和订阅者（即观察者）。当有新的新闻发布时，主题对象会通知所有的订阅者，并把最新的新闻内容传递给它们。订阅者可以是网站、移动应用或其他系统，它们根据收到的新闻内容来更新自己的展示界面或执行其他相关操作。

总结来说，观察者模式是一种用于实现对象间通信和状态更新的模式。它通过主题和观察者之间的订阅关系，实现了一种松耦合的方式，让对象之间能够灵活地相互通信和相应变化。

## 观察者模式和发布订阅模式的区别

观察者模式（Observer Pattern）中，主题对象和观察者对象之间存在一对多的依赖关系。主题对象维护了一个观察者列表，当主题状态发生变化时，会通知所有的观察者进行更新。观察者模式中的观察者们直接订阅主题，主题和观察者之间紧密关联。

而发布-订阅模式（Publish-Subscribe Pattern）中，引入了一个消息代理（或称为事件总线）作为中介。发布者（发布消息的对象）将消息发布到消息代理，而订阅者（订阅消息的对象）通过订阅特定类型的消息来接收通知。发布者和订阅者之间相互独立，它们不直接知道彼此的存在。

## 代码实现

```js
class Observer {
    constructor() {
        this.cache = []
    }
    subscribe(callback) {
        this.cache.push(callback)
    }

    unsubscribe(callback) {
        this.cache = this.cache.filter(item => item !== callback)
    }

    notify(...args){
        this.cache.length && this.cache.forEach(callback=>{
            callback(...args)
        })
    }
}

const observer = new Observer()
observer.subscribe((data)=>{
    console.log(data)
})

observer.notify('hello world')
```

